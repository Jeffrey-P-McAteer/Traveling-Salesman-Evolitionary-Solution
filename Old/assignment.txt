Travelling Salesman Approximation                                        [logo]

Due: December 5

Objective

To gain experience writing CUDA programs, and learn about genetic approximation
algorithms.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The Travelling Salesman Problem

The Travelling Salesman Problem (TSP) is a famous optimization problem. The
problem says that there is a salesman who needs to visit $N$ cities, stopping
at each city once, and then return home again. He would like to minimize the
amount of travel he has to do, so he would like to find the shortest possible
path through the cities.

TSP is extremely difficult to solve. With $N$ cities, there are $N!$ possible
paths. The obvious "brute force" approach is to compare all $N!$ paths to find
the shortest. This is not feasible for large values of $N$. For example, when
$N = 100$, $N! = 9.33 \times 10^{157}$. For comparison, the number of atoms in
the observable universe is estimated to be about $10^{80}$.

There are slightly more efficient algorithms for solving TSP that take a number
of steps proportional to $N^2 \times 2^N$. For 100 cities, this is still
approximately $1.27 \times 10^{34}$.

Rather than find an exact solution to TSP, what most do is find an approximate
solution. An approximation algorithm is one which finds a "good enough"
solution to a problem which may or may not be the best one possible.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Genetic Algorithms

There is a type of approximation algorithm that can be applied to a wide number
of optimization problems called genetic algorithms. A genetic algorithm borrows
concepts from biological evolution to iteratively improve upon a set of
solutions.

In a genetic algorithm, we maintain a population of solutions. In each step of
the algorithm, we determine the fitness of each member of the population - how
likely it is to survive. Then the members of the population who are least fit
are eliminated. Then new members are created by modifying the most fit members
of the population.

If we use a genetic algorithm to approximate TSP, the population will consist
of paths that visit every city. The fitness will be the total length of the
path. The most fit members of the population will be those with shorter total
lengths.

When the algorithm starts the population consists of entirely random paths.
Paths which have the greatest length will be removed. The new members of the
population can be created by randomly mutating the paths with the shortest
lengths: randomly changing the order of some of the cities. Sometimes, entirely
new random paths can be created which represent new species - this can avoid
the process being stuck in local minimums.

The exact details are left up to you:

 1. How many paths are in the population?
 2. What percentage die at each iteration?
 3. What percentage of the best solutions are new members based on?

 4. How exactly are new members mutated?
 5. Are entirely new random paths introduced? And how often?
 6. When does this process stop?

When the genetic algorithm finishes, the most fit member of the population is
given as the approximate solution.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Parallel Genetic Algorithms

Genetic algorithms are good candidates for being parallelized. There are
multiple approaches to this:

 1. Each node acts as an isolated continent: the solutions evolve independently
    and the best solution from any node is taken at the end.
 2. Each node acts as a region: the solutions evolve there, but there is
    migration where members move from one node to another.
 3. Each node represents one individual in the population: the node calculates
    the fitness of the individual and is responsible for mutating it when
    needed given information about the fit individual it should be based on.

Which approach you take is up to you.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Program Details

Your job is to use a parallel genetic algorithm, coded in CUDA, to solve an
instance of the TSP with $N = 100$, using some variant of the parallel genetic
algorithm described above.

The instance is given in the cities.txt file. There are 100 lines which each
contain an x and y coordinate of the city. Finding an exact solution to this
problem would take an inordinate amount of time on our computer systems.

Distances between the cities is simply the Euclidean distance between the
points which can be computed with the distance formula:

$d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$

The CUDA sqrt function can be used for this.

For random numbers, you will need to use the cuRAND functions as discussed in
class.

Your program should read in the input file (you can assume the file is always
named cities.txt and is in the same directory as your program).

Your program should output the best path you found along with the total
distance. The format of the path should be $c_1, c_2, c_3, ... c_N$ where each
$c_i$ is the index of the city you visit on the $i^{th}$ hop of the path. For
instance, if the output path begins:

84, 12, 62, 77, 5...

Then that means your best path visits the city on line 84 of the file first,
then the city on line 12, then the city on line 62 etc.

Your path must include the numbers $1 - N$ once each (it's assumed that the
salesman travels from the last city $c_N$ back to $c_1$ - his home city - at
the end). You must also output the total distance of that path.

The student who finds the best approximation for this instance of TSP will have
a 25% bonus added to their grade for this assignment (e.g. they could get a
125%). The student with the second best approximation will have a 10% bonus.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Submitting

In addition to your code, you should turn in a description of your program
including:

  • How your parallel genetic algorithm works including the population size,
    the way that the population is distributed across GPU cores, how many unfit
    members are killed, how you create new members etc.
  • How many CUDA blocks and/or threads did you request?
  • How many generations did you simulate?
  • How long did your program take to run?

Email the source code and this document to finlayson@umw.edu.

